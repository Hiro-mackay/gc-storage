// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: file_versions.sql

package sqlcgen

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const countFileVersionsByFileID = `-- name: CountFileVersionsByFileID :one
SELECT COUNT(*) FROM file_versions WHERE file_id = $1
`

func (q *Queries) CountFileVersionsByFileID(ctx context.Context, fileID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countFileVersionsByFileID, fileID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createFileVersion = `-- name: CreateFileVersion :one
INSERT INTO file_versions (
    id, file_id, version_number, minio_version_id, size, checksum, uploaded_by, created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, file_id, version_number, minio_version_id, size, checksum, uploaded_by, created_at
`

type CreateFileVersionParams struct {
	ID             uuid.UUID `json:"id"`
	FileID         uuid.UUID `json:"file_id"`
	VersionNumber  int32     `json:"version_number"`
	MinioVersionID *string   `json:"minio_version_id"`
	Size           int64     `json:"size"`
	Checksum       string    `json:"checksum"`
	UploadedBy     uuid.UUID `json:"uploaded_by"`
	CreatedAt      time.Time `json:"created_at"`
}

func (q *Queries) CreateFileVersion(ctx context.Context, arg CreateFileVersionParams) (FileVersion, error) {
	row := q.db.QueryRow(ctx, createFileVersion,
		arg.ID,
		arg.FileID,
		arg.VersionNumber,
		arg.MinioVersionID,
		arg.Size,
		arg.Checksum,
		arg.UploadedBy,
		arg.CreatedAt,
	)
	var i FileVersion
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.VersionNumber,
		&i.MinioVersionID,
		&i.Size,
		&i.Checksum,
		&i.UploadedBy,
		&i.CreatedAt,
	)
	return i, err
}

type CreateFileVersionsBulkParams struct {
	ID             uuid.UUID `json:"id"`
	FileID         uuid.UUID `json:"file_id"`
	VersionNumber  int32     `json:"version_number"`
	MinioVersionID *string   `json:"minio_version_id"`
	Size           int64     `json:"size"`
	Checksum       string    `json:"checksum"`
	UploadedBy     uuid.UUID `json:"uploaded_by"`
	CreatedAt      time.Time `json:"created_at"`
}

const deleteFileVersion = `-- name: DeleteFileVersion :exec
DELETE FROM file_versions WHERE id = $1
`

func (q *Queries) DeleteFileVersion(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteFileVersion, id)
	return err
}

const deleteFileVersionsByFileID = `-- name: DeleteFileVersionsByFileID :exec
DELETE FROM file_versions WHERE file_id = $1
`

func (q *Queries) DeleteFileVersionsByFileID(ctx context.Context, fileID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteFileVersionsByFileID, fileID)
	return err
}

const getFileVersionByFileAndVersion = `-- name: GetFileVersionByFileAndVersion :one
SELECT id, file_id, version_number, minio_version_id, size, checksum, uploaded_by, created_at FROM file_versions
WHERE file_id = $1 AND version_number = $2
`

type GetFileVersionByFileAndVersionParams struct {
	FileID        uuid.UUID `json:"file_id"`
	VersionNumber int32     `json:"version_number"`
}

func (q *Queries) GetFileVersionByFileAndVersion(ctx context.Context, arg GetFileVersionByFileAndVersionParams) (FileVersion, error) {
	row := q.db.QueryRow(ctx, getFileVersionByFileAndVersion, arg.FileID, arg.VersionNumber)
	var i FileVersion
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.VersionNumber,
		&i.MinioVersionID,
		&i.Size,
		&i.Checksum,
		&i.UploadedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getFileVersionByID = `-- name: GetFileVersionByID :one
SELECT id, file_id, version_number, minio_version_id, size, checksum, uploaded_by, created_at FROM file_versions WHERE id = $1
`

func (q *Queries) GetFileVersionByID(ctx context.Context, id uuid.UUID) (FileVersion, error) {
	row := q.db.QueryRow(ctx, getFileVersionByID, id)
	var i FileVersion
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.VersionNumber,
		&i.MinioVersionID,
		&i.Size,
		&i.Checksum,
		&i.UploadedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getLatestFileVersion = `-- name: GetLatestFileVersion :one
SELECT id, file_id, version_number, minio_version_id, size, checksum, uploaded_by, created_at FROM file_versions
WHERE file_id = $1
ORDER BY version_number DESC
LIMIT 1
`

func (q *Queries) GetLatestFileVersion(ctx context.Context, fileID uuid.UUID) (FileVersion, error) {
	row := q.db.QueryRow(ctx, getLatestFileVersion, fileID)
	var i FileVersion
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.VersionNumber,
		&i.MinioVersionID,
		&i.Size,
		&i.Checksum,
		&i.UploadedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getNextVersionNumber = `-- name: GetNextVersionNumber :one
SELECT COALESCE(MAX(version_number), 0) + 1 FROM file_versions WHERE file_id = $1
`

func (q *Queries) GetNextVersionNumber(ctx context.Context, fileID uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getNextVersionNumber, fileID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const listFileVersionsByFileID = `-- name: ListFileVersionsByFileID :many
SELECT id, file_id, version_number, minio_version_id, size, checksum, uploaded_by, created_at FROM file_versions
WHERE file_id = $1
ORDER BY version_number DESC
`

func (q *Queries) ListFileVersionsByFileID(ctx context.Context, fileID uuid.UUID) ([]FileVersion, error) {
	rows, err := q.db.Query(ctx, listFileVersionsByFileID, fileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FileVersion{}
	for rows.Next() {
		var i FileVersion
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.VersionNumber,
			&i.MinioVersionID,
			&i.Size,
			&i.Checksum,
			&i.UploadedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFileVersionsByFileIDs = `-- name: ListFileVersionsByFileIDs :many
SELECT id, file_id, version_number, minio_version_id, size, checksum, uploaded_by, created_at FROM file_versions
WHERE file_id = ANY($1::uuid[])
ORDER BY file_id, version_number DESC
`

func (q *Queries) ListFileVersionsByFileIDs(ctx context.Context, dollar_1 []uuid.UUID) ([]FileVersion, error) {
	rows, err := q.db.Query(ctx, listFileVersionsByFileIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FileVersion{}
	for rows.Next() {
		var i FileVersion
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.VersionNumber,
			&i.MinioVersionID,
			&i.Size,
			&i.Checksum,
			&i.UploadedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
