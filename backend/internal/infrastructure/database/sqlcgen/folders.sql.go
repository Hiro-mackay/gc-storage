// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: folders.sql

package sqlcgen

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const bulkUpdateFolderDepth = `-- name: BulkUpdateFolderDepth :exec
UPDATE folders SET depth = upd.depth, updated_at = NOW()
FROM (SELECT unnest($1::uuid[]) as id, unnest($2::int[]) as depth) as upd
WHERE folders.id = upd.id
`

type BulkUpdateFolderDepthParams struct {
	Column1 []uuid.UUID `json:"column_1"`
	Column2 []int32     `json:"column_2"`
}

func (q *Queries) BulkUpdateFolderDepth(ctx context.Context, arg BulkUpdateFolderDepthParams) error {
	_, err := q.db.Exec(ctx, bulkUpdateFolderDepth, arg.Column1, arg.Column2)
	return err
}

const createFolder = `-- name: CreateFolder :one
INSERT INTO folders (
    id, name, parent_id, owner_id, owner_type, depth, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, name, parent_id, owner_id, owner_type, depth, created_at, updated_at
`

type CreateFolderParams struct {
	ID        uuid.UUID   `json:"id"`
	Name      string      `json:"name"`
	ParentID  pgtype.UUID `json:"parent_id"`
	OwnerID   uuid.UUID   `json:"owner_id"`
	OwnerType OwnerType   `json:"owner_type"`
	Depth     int32       `json:"depth"`
	CreatedAt time.Time   `json:"created_at"`
	UpdatedAt time.Time   `json:"updated_at"`
}

func (q *Queries) CreateFolder(ctx context.Context, arg CreateFolderParams) (Folder, error) {
	row := q.db.QueryRow(ctx, createFolder,
		arg.ID,
		arg.Name,
		arg.ParentID,
		arg.OwnerID,
		arg.OwnerType,
		arg.Depth,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ParentID,
		&i.OwnerID,
		&i.OwnerType,
		&i.Depth,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteFolder = `-- name: DeleteFolder :exec
DELETE FROM folders WHERE id = $1
`

func (q *Queries) DeleteFolder(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteFolder, id)
	return err
}

const deleteFoldersBulk = `-- name: DeleteFoldersBulk :exec
DELETE FROM folders WHERE id = ANY($1::uuid[])
`

func (q *Queries) DeleteFoldersBulk(ctx context.Context, dollar_1 []uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteFoldersBulk, dollar_1)
	return err
}

const folderExistsByID = `-- name: FolderExistsByID :one
SELECT EXISTS(SELECT 1 FROM folders WHERE id = $1)
`

func (q *Queries) FolderExistsByID(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, folderExistsByID, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const folderExistsByNameAndParent = `-- name: FolderExistsByNameAndParent :one
SELECT EXISTS(
    SELECT 1 FROM folders
    WHERE parent_id = $1 AND owner_id = $2 AND owner_type = $3 AND name = $4
)
`

type FolderExistsByNameAndParentParams struct {
	ParentID  pgtype.UUID `json:"parent_id"`
	OwnerID   uuid.UUID   `json:"owner_id"`
	OwnerType OwnerType   `json:"owner_type"`
	Name      string      `json:"name"`
}

func (q *Queries) FolderExistsByNameAndParent(ctx context.Context, arg FolderExistsByNameAndParentParams) (bool, error) {
	row := q.db.QueryRow(ctx, folderExistsByNameAndParent,
		arg.ParentID,
		arg.OwnerID,
		arg.OwnerType,
		arg.Name,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const folderExistsByNameAtRoot = `-- name: FolderExistsByNameAtRoot :one
SELECT EXISTS(
    SELECT 1 FROM folders
    WHERE parent_id IS NULL AND owner_id = $1 AND owner_type = $2 AND name = $3
)
`

type FolderExistsByNameAtRootParams struct {
	OwnerID   uuid.UUID `json:"owner_id"`
	OwnerType OwnerType `json:"owner_type"`
	Name      string    `json:"name"`
}

func (q *Queries) FolderExistsByNameAtRoot(ctx context.Context, arg FolderExistsByNameAtRootParams) (bool, error) {
	row := q.db.QueryRow(ctx, folderExistsByNameAtRoot, arg.OwnerID, arg.OwnerType, arg.Name)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getFolderByID = `-- name: GetFolderByID :one
SELECT id, name, parent_id, owner_id, owner_type, depth, created_at, updated_at FROM folders WHERE id = $1
`

func (q *Queries) GetFolderByID(ctx context.Context, id uuid.UUID) (Folder, error) {
	row := q.db.QueryRow(ctx, getFolderByID, id)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ParentID,
		&i.OwnerID,
		&i.OwnerType,
		&i.Depth,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listFoldersByOwner = `-- name: ListFoldersByOwner :many
SELECT id, name, parent_id, owner_id, owner_type, depth, created_at, updated_at FROM folders
WHERE owner_id = $1 AND owner_type = $2
ORDER BY created_at DESC
`

type ListFoldersByOwnerParams struct {
	OwnerID   uuid.UUID `json:"owner_id"`
	OwnerType OwnerType `json:"owner_type"`
}

func (q *Queries) ListFoldersByOwner(ctx context.Context, arg ListFoldersByOwnerParams) ([]Folder, error) {
	rows, err := q.db.Query(ctx, listFoldersByOwner, arg.OwnerID, arg.OwnerType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ParentID,
			&i.OwnerID,
			&i.OwnerType,
			&i.Depth,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFoldersByParentID = `-- name: ListFoldersByParentID :many
SELECT id, name, parent_id, owner_id, owner_type, depth, created_at, updated_at FROM folders
WHERE parent_id = $1 AND owner_id = $2 AND owner_type = $3
ORDER BY name ASC
`

type ListFoldersByParentIDParams struct {
	ParentID  pgtype.UUID `json:"parent_id"`
	OwnerID   uuid.UUID   `json:"owner_id"`
	OwnerType OwnerType   `json:"owner_type"`
}

func (q *Queries) ListFoldersByParentID(ctx context.Context, arg ListFoldersByParentIDParams) ([]Folder, error) {
	rows, err := q.db.Query(ctx, listFoldersByParentID, arg.ParentID, arg.OwnerID, arg.OwnerType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ParentID,
			&i.OwnerID,
			&i.OwnerType,
			&i.Depth,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRootFoldersByOwner = `-- name: ListRootFoldersByOwner :many
SELECT id, name, parent_id, owner_id, owner_type, depth, created_at, updated_at FROM folders
WHERE parent_id IS NULL AND owner_id = $1 AND owner_type = $2
ORDER BY name ASC
`

type ListRootFoldersByOwnerParams struct {
	OwnerID   uuid.UUID `json:"owner_id"`
	OwnerType OwnerType `json:"owner_type"`
}

func (q *Queries) ListRootFoldersByOwner(ctx context.Context, arg ListRootFoldersByOwnerParams) ([]Folder, error) {
	rows, err := q.db.Query(ctx, listRootFoldersByOwner, arg.OwnerID, arg.OwnerType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ParentID,
			&i.OwnerID,
			&i.OwnerType,
			&i.Depth,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFolder = `-- name: UpdateFolder :one
UPDATE folders SET
    name = COALESCE($2, name),
    parent_id = COALESCE($3, parent_id),
    depth = COALESCE($4, depth),
    updated_at = NOW()
WHERE id = $1
RETURNING id, name, parent_id, owner_id, owner_type, depth, created_at, updated_at
`

type UpdateFolderParams struct {
	ID       uuid.UUID   `json:"id"`
	Name     *string     `json:"name"`
	ParentID pgtype.UUID `json:"parent_id"`
	Depth    *int32      `json:"depth"`
}

func (q *Queries) UpdateFolder(ctx context.Context, arg UpdateFolderParams) (Folder, error) {
	row := q.db.QueryRow(ctx, updateFolder,
		arg.ID,
		arg.Name,
		arg.ParentID,
		arg.Depth,
	)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ParentID,
		&i.OwnerID,
		&i.OwnerType,
		&i.Depth,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateFolderDepth = `-- name: UpdateFolderDepth :exec
UPDATE folders SET depth = $2, updated_at = NOW() WHERE id = $1
`

type UpdateFolderDepthParams struct {
	ID    uuid.UUID `json:"id"`
	Depth int32     `json:"depth"`
}

func (q *Queries) UpdateFolderDepth(ctx context.Context, arg UpdateFolderDepthParams) error {
	_, err := q.db.Exec(ctx, updateFolderDepth, arg.ID, arg.Depth)
	return err
}
