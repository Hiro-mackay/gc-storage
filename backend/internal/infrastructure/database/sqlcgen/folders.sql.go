// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: folders.sql

package sqlcgen

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countChildFolders = `-- name: CountChildFolders :one
SELECT COUNT(*) FROM folders
WHERE parent_id = $1 AND trashed_at IS NULL
`

func (q *Queries) CountChildFolders(ctx context.Context, parentID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countChildFolders, parentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createFolder = `-- name: CreateFolder :one
INSERT INTO folders (
    id, name, parent_id, owner_id, path, depth, is_root, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, name, parent_id, owner_id, path, depth, is_root, trashed_at, created_at, updated_at
`

type CreateFolderParams struct {
	ID        uuid.UUID   `json:"id"`
	Name      string      `json:"name"`
	ParentID  pgtype.UUID `json:"parent_id"`
	OwnerID   uuid.UUID   `json:"owner_id"`
	Path      string      `json:"path"`
	Depth     int32       `json:"depth"`
	IsRoot    bool        `json:"is_root"`
	CreatedAt time.Time   `json:"created_at"`
	UpdatedAt time.Time   `json:"updated_at"`
}

func (q *Queries) CreateFolder(ctx context.Context, arg CreateFolderParams) (Folder, error) {
	row := q.db.QueryRow(ctx, createFolder,
		arg.ID,
		arg.Name,
		arg.ParentID,
		arg.OwnerID,
		arg.Path,
		arg.Depth,
		arg.IsRoot,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ParentID,
		&i.OwnerID,
		&i.Path,
		&i.Depth,
		&i.IsRoot,
		&i.TrashedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteFolder = `-- name: DeleteFolder :exec
DELETE FROM folders WHERE id = $1
`

func (q *Queries) DeleteFolder(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteFolder, id)
	return err
}

const folderExistsByName = `-- name: FolderExistsByName :one
SELECT EXISTS(
    SELECT 1 FROM folders
    WHERE parent_id = $1 AND owner_id = $2 AND name = $3 AND trashed_at IS NULL
)
`

type FolderExistsByNameParams struct {
	ParentID pgtype.UUID `json:"parent_id"`
	OwnerID  uuid.UUID   `json:"owner_id"`
	Name     string      `json:"name"`
}

func (q *Queries) FolderExistsByName(ctx context.Context, arg FolderExistsByNameParams) (bool, error) {
	row := q.db.QueryRow(ctx, folderExistsByName, arg.ParentID, arg.OwnerID, arg.Name)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getFolderByID = `-- name: GetFolderByID :one
SELECT id, name, parent_id, owner_id, path, depth, is_root, trashed_at, created_at, updated_at FROM folders WHERE id = $1
`

func (q *Queries) GetFolderByID(ctx context.Context, id uuid.UUID) (Folder, error) {
	row := q.db.QueryRow(ctx, getFolderByID, id)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ParentID,
		&i.OwnerID,
		&i.Path,
		&i.Depth,
		&i.IsRoot,
		&i.TrashedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFoldersToAutoDelete = `-- name: GetFoldersToAutoDelete :many
SELECT id, name, parent_id, owner_id, path, depth, is_root, trashed_at, created_at, updated_at FROM folders
WHERE trashed_at IS NOT NULL AND trashed_at < $1
`

func (q *Queries) GetFoldersToAutoDelete(ctx context.Context, trashedAt pgtype.Timestamptz) ([]Folder, error) {
	rows, err := q.db.Query(ctx, getFoldersToAutoDelete, trashedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ParentID,
			&i.OwnerID,
			&i.Path,
			&i.Depth,
			&i.IsRoot,
			&i.TrashedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRootFolderByOwnerID = `-- name: GetRootFolderByOwnerID :one
SELECT id, name, parent_id, owner_id, path, depth, is_root, trashed_at, created_at, updated_at FROM folders WHERE owner_id = $1 AND is_root = TRUE
`

func (q *Queries) GetRootFolderByOwnerID(ctx context.Context, ownerID uuid.UUID) (Folder, error) {
	row := q.db.QueryRow(ctx, getRootFolderByOwnerID, ownerID)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ParentID,
		&i.OwnerID,
		&i.Path,
		&i.Depth,
		&i.IsRoot,
		&i.TrashedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listDescendantFolders = `-- name: ListDescendantFolders :many
SELECT id, name, parent_id, owner_id, path, depth, is_root, trashed_at, created_at, updated_at FROM folders
WHERE path LIKE $1 || '/%'
ORDER BY depth ASC
`

func (q *Queries) ListDescendantFolders(ctx context.Context, dollar_1 *string) ([]Folder, error) {
	rows, err := q.db.Query(ctx, listDescendantFolders, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ParentID,
			&i.OwnerID,
			&i.Path,
			&i.Depth,
			&i.IsRoot,
			&i.TrashedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFoldersByOwnerID = `-- name: ListFoldersByOwnerID :many
SELECT id, name, parent_id, owner_id, path, depth, is_root, trashed_at, created_at, updated_at FROM folders
WHERE owner_id = $1 AND trashed_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListFoldersByOwnerID(ctx context.Context, ownerID uuid.UUID) ([]Folder, error) {
	rows, err := q.db.Query(ctx, listFoldersByOwnerID, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ParentID,
			&i.OwnerID,
			&i.Path,
			&i.Depth,
			&i.IsRoot,
			&i.TrashedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFoldersByParentID = `-- name: ListFoldersByParentID :many
SELECT id, name, parent_id, owner_id, path, depth, is_root, trashed_at, created_at, updated_at FROM folders
WHERE parent_id = $1 AND trashed_at IS NULL
ORDER BY name ASC
`

func (q *Queries) ListFoldersByParentID(ctx context.Context, parentID pgtype.UUID) ([]Folder, error) {
	rows, err := q.db.Query(ctx, listFoldersByParentID, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ParentID,
			&i.OwnerID,
			&i.Path,
			&i.Depth,
			&i.IsRoot,
			&i.TrashedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFoldersByPath = `-- name: ListFoldersByPath :many
SELECT id, name, parent_id, owner_id, path, depth, is_root, trashed_at, created_at, updated_at FROM folders
WHERE path LIKE $1 || '%'
ORDER BY depth ASC
`

func (q *Queries) ListFoldersByPath(ctx context.Context, dollar_1 *string) ([]Folder, error) {
	rows, err := q.db.Query(ctx, listFoldersByPath, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ParentID,
			&i.OwnerID,
			&i.Path,
			&i.Depth,
			&i.IsRoot,
			&i.TrashedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTrashedFoldersByOwnerID = `-- name: ListTrashedFoldersByOwnerID :many
SELECT id, name, parent_id, owner_id, path, depth, is_root, trashed_at, created_at, updated_at FROM folders
WHERE owner_id = $1 AND trashed_at IS NOT NULL
ORDER BY trashed_at DESC
`

func (q *Queries) ListTrashedFoldersByOwnerID(ctx context.Context, ownerID uuid.UUID) ([]Folder, error) {
	rows, err := q.db.Query(ctx, listTrashedFoldersByOwnerID, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Folder{}
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ParentID,
			&i.OwnerID,
			&i.Path,
			&i.Depth,
			&i.IsRoot,
			&i.TrashedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreFolder = `-- name: RestoreFolder :exec
UPDATE folders SET trashed_at = NULL, updated_at = NOW() WHERE id = $1
`

func (q *Queries) RestoreFolder(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, restoreFolder, id)
	return err
}

const trashFolder = `-- name: TrashFolder :exec
UPDATE folders SET trashed_at = NOW(), updated_at = NOW() WHERE id = $1
`

func (q *Queries) TrashFolder(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, trashFolder, id)
	return err
}

const updateFolder = `-- name: UpdateFolder :one
UPDATE folders SET
    name = COALESCE($2, name),
    parent_id = COALESCE($3, parent_id),
    path = COALESCE($4, path),
    depth = COALESCE($5, depth),
    updated_at = NOW()
WHERE id = $1
RETURNING id, name, parent_id, owner_id, path, depth, is_root, trashed_at, created_at, updated_at
`

type UpdateFolderParams struct {
	ID       uuid.UUID   `json:"id"`
	Name     *string     `json:"name"`
	ParentID pgtype.UUID `json:"parent_id"`
	Path     *string     `json:"path"`
	Depth    *int32      `json:"depth"`
}

func (q *Queries) UpdateFolder(ctx context.Context, arg UpdateFolderParams) (Folder, error) {
	row := q.db.QueryRow(ctx, updateFolder,
		arg.ID,
		arg.Name,
		arg.ParentID,
		arg.Path,
		arg.Depth,
	)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ParentID,
		&i.OwnerID,
		&i.Path,
		&i.Depth,
		&i.IsRoot,
		&i.TrashedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateFolderPath = `-- name: UpdateFolderPath :exec
UPDATE folders SET
    path = $2,
    depth = $3,
    updated_at = NOW()
WHERE id = $1
`

type UpdateFolderPathParams struct {
	ID    uuid.UUID `json:"id"`
	Path  string    `json:"path"`
	Depth int32     `json:"depth"`
}

func (q *Queries) UpdateFolderPath(ctx context.Context, arg UpdateFolderPathParams) error {
	_, err := q.db.Exec(ctx, updateFolderPath, arg.ID, arg.Path, arg.Depth)
	return err
}
