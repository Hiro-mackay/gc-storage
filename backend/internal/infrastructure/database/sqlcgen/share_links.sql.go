// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: share_links.sql

package sqlcgen

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createShareLink = `-- name: CreateShareLink :one
INSERT INTO share_links (
    id, token, resource_type, resource_id, created_by, permission,
    password_hash, expires_at, max_access_count, access_count, status, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING id, token, resource_type, resource_id, created_by, permission, password_hash, expires_at, max_access_count, access_count, status, created_at, updated_at
`

type CreateShareLinkParams struct {
	ID             uuid.UUID          `json:"id"`
	Token          string             `json:"token"`
	ResourceType   string             `json:"resource_type"`
	ResourceID     uuid.UUID          `json:"resource_id"`
	CreatedBy      uuid.UUID          `json:"created_by"`
	Permission     string             `json:"permission"`
	PasswordHash   *string            `json:"password_hash"`
	ExpiresAt      pgtype.Timestamptz `json:"expires_at"`
	MaxAccessCount *int32             `json:"max_access_count"`
	AccessCount    int32              `json:"access_count"`
	Status         string             `json:"status"`
	CreatedAt      time.Time          `json:"created_at"`
	UpdatedAt      time.Time          `json:"updated_at"`
}

func (q *Queries) CreateShareLink(ctx context.Context, arg CreateShareLinkParams) (ShareLink, error) {
	row := q.db.QueryRow(ctx, createShareLink,
		arg.ID,
		arg.Token,
		arg.ResourceType,
		arg.ResourceID,
		arg.CreatedBy,
		arg.Permission,
		arg.PasswordHash,
		arg.ExpiresAt,
		arg.MaxAccessCount,
		arg.AccessCount,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i ShareLink
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.ResourceType,
		&i.ResourceID,
		&i.CreatedBy,
		&i.Permission,
		&i.PasswordHash,
		&i.ExpiresAt,
		&i.MaxAccessCount,
		&i.AccessCount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteShareLink = `-- name: DeleteShareLink :exec
DELETE FROM share_links WHERE id = $1
`

func (q *Queries) DeleteShareLink(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteShareLink, id)
	return err
}

const getShareLinkByID = `-- name: GetShareLinkByID :one
SELECT id, token, resource_type, resource_id, created_by, permission, password_hash, expires_at, max_access_count, access_count, status, created_at, updated_at FROM share_links WHERE id = $1
`

func (q *Queries) GetShareLinkByID(ctx context.Context, id uuid.UUID) (ShareLink, error) {
	row := q.db.QueryRow(ctx, getShareLinkByID, id)
	var i ShareLink
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.ResourceType,
		&i.ResourceID,
		&i.CreatedBy,
		&i.Permission,
		&i.PasswordHash,
		&i.ExpiresAt,
		&i.MaxAccessCount,
		&i.AccessCount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getShareLinkByToken = `-- name: GetShareLinkByToken :one
SELECT id, token, resource_type, resource_id, created_by, permission, password_hash, expires_at, max_access_count, access_count, status, created_at, updated_at FROM share_links WHERE token = $1
`

func (q *Queries) GetShareLinkByToken(ctx context.Context, token string) (ShareLink, error) {
	row := q.db.QueryRow(ctx, getShareLinkByToken, token)
	var i ShareLink
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.ResourceType,
		&i.ResourceID,
		&i.CreatedBy,
		&i.Permission,
		&i.PasswordHash,
		&i.ExpiresAt,
		&i.MaxAccessCount,
		&i.AccessCount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementShareLinkAccessCount = `-- name: IncrementShareLinkAccessCount :exec
UPDATE share_links SET access_count = access_count + 1, updated_at = NOW() WHERE id = $1
`

func (q *Queries) IncrementShareLinkAccessCount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementShareLinkAccessCount, id)
	return err
}

const listActiveShareLinksByResource = `-- name: ListActiveShareLinksByResource :many
SELECT id, token, resource_type, resource_id, created_by, permission, password_hash, expires_at, max_access_count, access_count, status, created_at, updated_at FROM share_links
WHERE resource_type = $1 AND resource_id = $2 AND status = 'active'
ORDER BY created_at DESC
`

type ListActiveShareLinksByResourceParams struct {
	ResourceType string    `json:"resource_type"`
	ResourceID   uuid.UUID `json:"resource_id"`
}

func (q *Queries) ListActiveShareLinksByResource(ctx context.Context, arg ListActiveShareLinksByResourceParams) ([]ShareLink, error) {
	rows, err := q.db.Query(ctx, listActiveShareLinksByResource, arg.ResourceType, arg.ResourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ShareLink{}
	for rows.Next() {
		var i ShareLink
		if err := rows.Scan(
			&i.ID,
			&i.Token,
			&i.ResourceType,
			&i.ResourceID,
			&i.CreatedBy,
			&i.Permission,
			&i.PasswordHash,
			&i.ExpiresAt,
			&i.MaxAccessCount,
			&i.AccessCount,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExpiredShareLinks = `-- name: ListExpiredShareLinks :many
SELECT id, token, resource_type, resource_id, created_by, permission, password_hash, expires_at, max_access_count, access_count, status, created_at, updated_at FROM share_links
WHERE status = 'active' AND expires_at IS NOT NULL AND expires_at < NOW()
`

func (q *Queries) ListExpiredShareLinks(ctx context.Context) ([]ShareLink, error) {
	rows, err := q.db.Query(ctx, listExpiredShareLinks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ShareLink{}
	for rows.Next() {
		var i ShareLink
		if err := rows.Scan(
			&i.ID,
			&i.Token,
			&i.ResourceType,
			&i.ResourceID,
			&i.CreatedBy,
			&i.Permission,
			&i.PasswordHash,
			&i.ExpiresAt,
			&i.MaxAccessCount,
			&i.AccessCount,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShareLinksByCreator = `-- name: ListShareLinksByCreator :many
SELECT id, token, resource_type, resource_id, created_by, permission, password_hash, expires_at, max_access_count, access_count, status, created_at, updated_at FROM share_links
WHERE created_by = $1
ORDER BY created_at DESC
`

func (q *Queries) ListShareLinksByCreator(ctx context.Context, createdBy uuid.UUID) ([]ShareLink, error) {
	rows, err := q.db.Query(ctx, listShareLinksByCreator, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ShareLink{}
	for rows.Next() {
		var i ShareLink
		if err := rows.Scan(
			&i.ID,
			&i.Token,
			&i.ResourceType,
			&i.ResourceID,
			&i.CreatedBy,
			&i.Permission,
			&i.PasswordHash,
			&i.ExpiresAt,
			&i.MaxAccessCount,
			&i.AccessCount,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShareLinksByResource = `-- name: ListShareLinksByResource :many
SELECT id, token, resource_type, resource_id, created_by, permission, password_hash, expires_at, max_access_count, access_count, status, created_at, updated_at FROM share_links
WHERE resource_type = $1 AND resource_id = $2
ORDER BY created_at DESC
`

type ListShareLinksByResourceParams struct {
	ResourceType string    `json:"resource_type"`
	ResourceID   uuid.UUID `json:"resource_id"`
}

func (q *Queries) ListShareLinksByResource(ctx context.Context, arg ListShareLinksByResourceParams) ([]ShareLink, error) {
	rows, err := q.db.Query(ctx, listShareLinksByResource, arg.ResourceType, arg.ResourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ShareLink{}
	for rows.Next() {
		var i ShareLink
		if err := rows.Scan(
			&i.ID,
			&i.Token,
			&i.ResourceType,
			&i.ResourceID,
			&i.CreatedBy,
			&i.Permission,
			&i.PasswordHash,
			&i.ExpiresAt,
			&i.MaxAccessCount,
			&i.AccessCount,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateShareLink = `-- name: UpdateShareLink :one
UPDATE share_links SET
    permission = COALESCE($2, permission),
    password_hash = COALESCE($3, password_hash),
    expires_at = COALESCE($4, expires_at),
    max_access_count = COALESCE($5, max_access_count),
    access_count = COALESCE($6, access_count),
    status = COALESCE($7, status),
    updated_at = NOW()
WHERE id = $1
RETURNING id, token, resource_type, resource_id, created_by, permission, password_hash, expires_at, max_access_count, access_count, status, created_at, updated_at
`

type UpdateShareLinkParams struct {
	ID             uuid.UUID          `json:"id"`
	Permission     *string            `json:"permission"`
	PasswordHash   *string            `json:"password_hash"`
	ExpiresAt      pgtype.Timestamptz `json:"expires_at"`
	MaxAccessCount *int32             `json:"max_access_count"`
	AccessCount    *int32             `json:"access_count"`
	Status         *string            `json:"status"`
}

func (q *Queries) UpdateShareLink(ctx context.Context, arg UpdateShareLinkParams) (ShareLink, error) {
	row := q.db.QueryRow(ctx, updateShareLink,
		arg.ID,
		arg.Permission,
		arg.PasswordHash,
		arg.ExpiresAt,
		arg.MaxAccessCount,
		arg.AccessCount,
		arg.Status,
	)
	var i ShareLink
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.ResourceType,
		&i.ResourceID,
		&i.CreatedBy,
		&i.Permission,
		&i.PasswordHash,
		&i.ExpiresAt,
		&i.MaxAccessCount,
		&i.AccessCount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateShareLinksStatusBatch = `-- name: UpdateShareLinksStatusBatch :execrows
UPDATE share_links
SET status = $2, updated_at = NOW()
WHERE id = ANY($1::uuid[])
`

type UpdateShareLinksStatusBatchParams struct {
	Column1 []uuid.UUID `json:"column_1"`
	Status  string      `json:"status"`
}

func (q *Queries) UpdateShareLinksStatusBatch(ctx context.Context, arg UpdateShareLinksStatusBatchParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateShareLinksStatusBatch, arg.Column1, arg.Status)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
