// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: share_links.sql

package sqlcgen

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countShareLinksByResource = `-- name: CountShareLinksByResource :one
SELECT COUNT(*) FROM share_links
WHERE resource_type = $1 AND resource_id = $2 AND is_active = TRUE
`

type CountShareLinksByResourceParams struct {
	ResourceType string    `json:"resource_type"`
	ResourceID   uuid.UUID `json:"resource_id"`
}

func (q *Queries) CountShareLinksByResource(ctx context.Context, arg CountShareLinksByResourceParams) (int64, error) {
	row := q.db.QueryRow(ctx, countShareLinksByResource, arg.ResourceType, arg.ResourceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createShareLink = `-- name: CreateShareLink :one
INSERT INTO share_links (
    id, resource_type, resource_id, token, permission, password_hash, max_downloads, expires_at, is_active, created_by, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING id, resource_type, resource_id, token, permission, password_hash, max_downloads, download_count, expires_at, is_active, created_by, created_at, updated_at
`

type CreateShareLinkParams struct {
	ID           uuid.UUID          `json:"id"`
	ResourceType string             `json:"resource_type"`
	ResourceID   uuid.UUID          `json:"resource_id"`
	Token        string             `json:"token"`
	Permission   string             `json:"permission"`
	PasswordHash *string            `json:"password_hash"`
	MaxDownloads *int32             `json:"max_downloads"`
	ExpiresAt    pgtype.Timestamptz `json:"expires_at"`
	IsActive     bool               `json:"is_active"`
	CreatedBy    uuid.UUID          `json:"created_by"`
	CreatedAt    time.Time          `json:"created_at"`
	UpdatedAt    time.Time          `json:"updated_at"`
}

func (q *Queries) CreateShareLink(ctx context.Context, arg CreateShareLinkParams) (ShareLink, error) {
	row := q.db.QueryRow(ctx, createShareLink,
		arg.ID,
		arg.ResourceType,
		arg.ResourceID,
		arg.Token,
		arg.Permission,
		arg.PasswordHash,
		arg.MaxDownloads,
		arg.ExpiresAt,
		arg.IsActive,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i ShareLink
	err := row.Scan(
		&i.ID,
		&i.ResourceType,
		&i.ResourceID,
		&i.Token,
		&i.Permission,
		&i.PasswordHash,
		&i.MaxDownloads,
		&i.DownloadCount,
		&i.ExpiresAt,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateExpiredShareLinks = `-- name: DeactivateExpiredShareLinks :exec
UPDATE share_links SET is_active = FALSE, updated_at = NOW()
WHERE is_active = TRUE AND expires_at IS NOT NULL AND expires_at < NOW()
`

func (q *Queries) DeactivateExpiredShareLinks(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deactivateExpiredShareLinks)
	return err
}

const deactivateShareLink = `-- name: DeactivateShareLink :exec
UPDATE share_links SET is_active = FALSE, updated_at = NOW() WHERE id = $1
`

func (q *Queries) DeactivateShareLink(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deactivateShareLink, id)
	return err
}

const deleteShareLink = `-- name: DeleteShareLink :exec
DELETE FROM share_links WHERE id = $1
`

func (q *Queries) DeleteShareLink(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteShareLink, id)
	return err
}

const getActiveShareLinkByToken = `-- name: GetActiveShareLinkByToken :one
SELECT id, resource_type, resource_id, token, permission, password_hash, max_downloads, download_count, expires_at, is_active, created_by, created_at, updated_at FROM share_links
WHERE token = $1 AND is_active = TRUE
AND (expires_at IS NULL OR expires_at > NOW())
AND (max_downloads IS NULL OR download_count < max_downloads)
`

func (q *Queries) GetActiveShareLinkByToken(ctx context.Context, token string) (ShareLink, error) {
	row := q.db.QueryRow(ctx, getActiveShareLinkByToken, token)
	var i ShareLink
	err := row.Scan(
		&i.ID,
		&i.ResourceType,
		&i.ResourceID,
		&i.Token,
		&i.Permission,
		&i.PasswordHash,
		&i.MaxDownloads,
		&i.DownloadCount,
		&i.ExpiresAt,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getShareLinkByID = `-- name: GetShareLinkByID :one
SELECT id, resource_type, resource_id, token, permission, password_hash, max_downloads, download_count, expires_at, is_active, created_by, created_at, updated_at FROM share_links WHERE id = $1
`

func (q *Queries) GetShareLinkByID(ctx context.Context, id uuid.UUID) (ShareLink, error) {
	row := q.db.QueryRow(ctx, getShareLinkByID, id)
	var i ShareLink
	err := row.Scan(
		&i.ID,
		&i.ResourceType,
		&i.ResourceID,
		&i.Token,
		&i.Permission,
		&i.PasswordHash,
		&i.MaxDownloads,
		&i.DownloadCount,
		&i.ExpiresAt,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getShareLinkByToken = `-- name: GetShareLinkByToken :one
SELECT id, resource_type, resource_id, token, permission, password_hash, max_downloads, download_count, expires_at, is_active, created_by, created_at, updated_at FROM share_links WHERE token = $1
`

func (q *Queries) GetShareLinkByToken(ctx context.Context, token string) (ShareLink, error) {
	row := q.db.QueryRow(ctx, getShareLinkByToken, token)
	var i ShareLink
	err := row.Scan(
		&i.ID,
		&i.ResourceType,
		&i.ResourceID,
		&i.Token,
		&i.Permission,
		&i.PasswordHash,
		&i.MaxDownloads,
		&i.DownloadCount,
		&i.ExpiresAt,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementDownloadCount = `-- name: IncrementDownloadCount :exec
UPDATE share_links SET download_count = download_count + 1 WHERE id = $1
`

func (q *Queries) IncrementDownloadCount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementDownloadCount, id)
	return err
}

const listActiveShareLinks = `-- name: ListActiveShareLinks :many
SELECT id, resource_type, resource_id, token, permission, password_hash, max_downloads, download_count, expires_at, is_active, created_by, created_at, updated_at FROM share_links
WHERE is_active = TRUE
AND (expires_at IS NULL OR expires_at > NOW())
ORDER BY created_at DESC
`

func (q *Queries) ListActiveShareLinks(ctx context.Context) ([]ShareLink, error) {
	rows, err := q.db.Query(ctx, listActiveShareLinks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ShareLink{}
	for rows.Next() {
		var i ShareLink
		if err := rows.Scan(
			&i.ID,
			&i.ResourceType,
			&i.ResourceID,
			&i.Token,
			&i.Permission,
			&i.PasswordHash,
			&i.MaxDownloads,
			&i.DownloadCount,
			&i.ExpiresAt,
			&i.IsActive,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShareLinksByCreator = `-- name: ListShareLinksByCreator :many
SELECT id, resource_type, resource_id, token, permission, password_hash, max_downloads, download_count, expires_at, is_active, created_by, created_at, updated_at FROM share_links
WHERE created_by = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListShareLinksByCreatorParams struct {
	CreatedBy uuid.UUID `json:"created_by"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

func (q *Queries) ListShareLinksByCreator(ctx context.Context, arg ListShareLinksByCreatorParams) ([]ShareLink, error) {
	rows, err := q.db.Query(ctx, listShareLinksByCreator, arg.CreatedBy, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ShareLink{}
	for rows.Next() {
		var i ShareLink
		if err := rows.Scan(
			&i.ID,
			&i.ResourceType,
			&i.ResourceID,
			&i.Token,
			&i.Permission,
			&i.PasswordHash,
			&i.MaxDownloads,
			&i.DownloadCount,
			&i.ExpiresAt,
			&i.IsActive,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShareLinksByResource = `-- name: ListShareLinksByResource :many
SELECT id, resource_type, resource_id, token, permission, password_hash, max_downloads, download_count, expires_at, is_active, created_by, created_at, updated_at FROM share_links
WHERE resource_type = $1 AND resource_id = $2
ORDER BY created_at DESC
`

type ListShareLinksByResourceParams struct {
	ResourceType string    `json:"resource_type"`
	ResourceID   uuid.UUID `json:"resource_id"`
}

func (q *Queries) ListShareLinksByResource(ctx context.Context, arg ListShareLinksByResourceParams) ([]ShareLink, error) {
	rows, err := q.db.Query(ctx, listShareLinksByResource, arg.ResourceType, arg.ResourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ShareLink{}
	for rows.Next() {
		var i ShareLink
		if err := rows.Scan(
			&i.ID,
			&i.ResourceType,
			&i.ResourceID,
			&i.Token,
			&i.Permission,
			&i.PasswordHash,
			&i.MaxDownloads,
			&i.DownloadCount,
			&i.ExpiresAt,
			&i.IsActive,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateShareLink = `-- name: UpdateShareLink :one
UPDATE share_links SET
    permission = COALESCE($2, permission),
    password_hash = COALESCE($3, password_hash),
    max_downloads = COALESCE($4, max_downloads),
    expires_at = COALESCE($5, expires_at),
    is_active = COALESCE($6, is_active),
    updated_at = NOW()
WHERE id = $1
RETURNING id, resource_type, resource_id, token, permission, password_hash, max_downloads, download_count, expires_at, is_active, created_by, created_at, updated_at
`

type UpdateShareLinkParams struct {
	ID           uuid.UUID          `json:"id"`
	Permission   *string            `json:"permission"`
	PasswordHash *string            `json:"password_hash"`
	MaxDownloads *int32             `json:"max_downloads"`
	ExpiresAt    pgtype.Timestamptz `json:"expires_at"`
	IsActive     *bool              `json:"is_active"`
}

func (q *Queries) UpdateShareLink(ctx context.Context, arg UpdateShareLinkParams) (ShareLink, error) {
	row := q.db.QueryRow(ctx, updateShareLink,
		arg.ID,
		arg.Permission,
		arg.PasswordHash,
		arg.MaxDownloads,
		arg.ExpiresAt,
		arg.IsActive,
	)
	var i ShareLink
	err := row.Scan(
		&i.ID,
		&i.ResourceType,
		&i.ResourceID,
		&i.Token,
		&i.Permission,
		&i.PasswordHash,
		&i.MaxDownloads,
		&i.DownloadCount,
		&i.ExpiresAt,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
