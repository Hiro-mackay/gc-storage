// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: relationships.sql

package sqlcgen

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createRelationship = `-- name: CreateRelationship :one
INSERT INTO relationships (
    id, subject_type, subject_id, relation, object_type, object_id, created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, subject_type, subject_id, relation, object_type, object_id, created_at
`

type CreateRelationshipParams struct {
	ID          uuid.UUID `json:"id"`
	SubjectType string    `json:"subject_type"`
	SubjectID   uuid.UUID `json:"subject_id"`
	Relation    string    `json:"relation"`
	ObjectType  string    `json:"object_type"`
	ObjectID    uuid.UUID `json:"object_id"`
	CreatedAt   time.Time `json:"created_at"`
}

func (q *Queries) CreateRelationship(ctx context.Context, arg CreateRelationshipParams) (Relationship, error) {
	row := q.db.QueryRow(ctx, createRelationship,
		arg.ID,
		arg.SubjectType,
		arg.SubjectID,
		arg.Relation,
		arg.ObjectType,
		arg.ObjectID,
		arg.CreatedAt,
	)
	var i Relationship
	err := row.Scan(
		&i.ID,
		&i.SubjectType,
		&i.SubjectID,
		&i.Relation,
		&i.ObjectType,
		&i.ObjectID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteRelationship = `-- name: DeleteRelationship :exec
DELETE FROM relationships WHERE id = $1
`

func (q *Queries) DeleteRelationship(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRelationship, id)
	return err
}

const deleteRelationshipByTuple = `-- name: DeleteRelationshipByTuple :exec
DELETE FROM relationships
WHERE subject_type = $1 AND subject_id = $2 AND relation = $3 AND object_type = $4 AND object_id = $5
`

type DeleteRelationshipByTupleParams struct {
	SubjectType string    `json:"subject_type"`
	SubjectID   uuid.UUID `json:"subject_id"`
	Relation    string    `json:"relation"`
	ObjectType  string    `json:"object_type"`
	ObjectID    uuid.UUID `json:"object_id"`
}

func (q *Queries) DeleteRelationshipByTuple(ctx context.Context, arg DeleteRelationshipByTupleParams) error {
	_, err := q.db.Exec(ctx, deleteRelationshipByTuple,
		arg.SubjectType,
		arg.SubjectID,
		arg.Relation,
		arg.ObjectType,
		arg.ObjectID,
	)
	return err
}

const deleteRelationshipsByObject = `-- name: DeleteRelationshipsByObject :exec
DELETE FROM relationships WHERE object_type = $1 AND object_id = $2
`

type DeleteRelationshipsByObjectParams struct {
	ObjectType string    `json:"object_type"`
	ObjectID   uuid.UUID `json:"object_id"`
}

func (q *Queries) DeleteRelationshipsByObject(ctx context.Context, arg DeleteRelationshipsByObjectParams) error {
	_, err := q.db.Exec(ctx, deleteRelationshipsByObject, arg.ObjectType, arg.ObjectID)
	return err
}

const deleteRelationshipsBySubject = `-- name: DeleteRelationshipsBySubject :exec
DELETE FROM relationships WHERE subject_type = $1 AND subject_id = $2
`

type DeleteRelationshipsBySubjectParams struct {
	SubjectType string    `json:"subject_type"`
	SubjectID   uuid.UUID `json:"subject_id"`
}

func (q *Queries) DeleteRelationshipsBySubject(ctx context.Context, arg DeleteRelationshipsBySubjectParams) error {
	_, err := q.db.Exec(ctx, deleteRelationshipsBySubject, arg.SubjectType, arg.SubjectID)
	return err
}

const findObjectsBySubject = `-- name: FindObjectsBySubject :many
SELECT object_id FROM relationships
WHERE subject_type = $1 AND subject_id = $2 AND relation = $3 AND object_type = $4
`

type FindObjectsBySubjectParams struct {
	SubjectType string    `json:"subject_type"`
	SubjectID   uuid.UUID `json:"subject_id"`
	Relation    string    `json:"relation"`
	ObjectType  string    `json:"object_type"`
}

func (q *Queries) FindObjectsBySubject(ctx context.Context, arg FindObjectsBySubjectParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, findObjectsBySubject,
		arg.SubjectType,
		arg.SubjectID,
		arg.Relation,
		arg.ObjectType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.UUID{}
	for rows.Next() {
		var object_id uuid.UUID
		if err := rows.Scan(&object_id); err != nil {
			return nil, err
		}
		items = append(items, object_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findParentRelationship = `-- name: FindParentRelationship :one
SELECT subject_type, subject_id FROM relationships
WHERE object_type = $1 AND object_id = $2 AND relation = 'parent'
LIMIT 1
`

type FindParentRelationshipParams struct {
	ObjectType string    `json:"object_type"`
	ObjectID   uuid.UUID `json:"object_id"`
}

type FindParentRelationshipRow struct {
	SubjectType string    `json:"subject_type"`
	SubjectID   uuid.UUID `json:"subject_id"`
}

func (q *Queries) FindParentRelationship(ctx context.Context, arg FindParentRelationshipParams) (FindParentRelationshipRow, error) {
	row := q.db.QueryRow(ctx, findParentRelationship, arg.ObjectType, arg.ObjectID)
	var i FindParentRelationshipRow
	err := row.Scan(&i.SubjectType, &i.SubjectID)
	return i, err
}

const findSubjectsByObject = `-- name: FindSubjectsByObject :many
SELECT subject_type, subject_id FROM relationships
WHERE object_type = $1 AND object_id = $2 AND relation = $3
`

type FindSubjectsByObjectParams struct {
	ObjectType string    `json:"object_type"`
	ObjectID   uuid.UUID `json:"object_id"`
	Relation   string    `json:"relation"`
}

type FindSubjectsByObjectRow struct {
	SubjectType string    `json:"subject_type"`
	SubjectID   uuid.UUID `json:"subject_id"`
}

func (q *Queries) FindSubjectsByObject(ctx context.Context, arg FindSubjectsByObjectParams) ([]FindSubjectsByObjectRow, error) {
	rows, err := q.db.Query(ctx, findSubjectsByObject, arg.ObjectType, arg.ObjectID, arg.Relation)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindSubjectsByObjectRow{}
	for rows.Next() {
		var i FindSubjectsByObjectRow
		if err := rows.Scan(&i.SubjectType, &i.SubjectID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRelationshipsByObject = `-- name: ListRelationshipsByObject :many
SELECT id, subject_type, subject_id, relation, object_type, object_id, created_at FROM relationships
WHERE object_type = $1 AND object_id = $2
ORDER BY created_at DESC
`

type ListRelationshipsByObjectParams struct {
	ObjectType string    `json:"object_type"`
	ObjectID   uuid.UUID `json:"object_id"`
}

func (q *Queries) ListRelationshipsByObject(ctx context.Context, arg ListRelationshipsByObjectParams) ([]Relationship, error) {
	rows, err := q.db.Query(ctx, listRelationshipsByObject, arg.ObjectType, arg.ObjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Relationship{}
	for rows.Next() {
		var i Relationship
		if err := rows.Scan(
			&i.ID,
			&i.SubjectType,
			&i.SubjectID,
			&i.Relation,
			&i.ObjectType,
			&i.ObjectID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRelationshipsBySubject = `-- name: ListRelationshipsBySubject :many
SELECT id, subject_type, subject_id, relation, object_type, object_id, created_at FROM relationships
WHERE subject_type = $1 AND subject_id = $2
ORDER BY created_at DESC
`

type ListRelationshipsBySubjectParams struct {
	SubjectType string    `json:"subject_type"`
	SubjectID   uuid.UUID `json:"subject_id"`
}

func (q *Queries) ListRelationshipsBySubject(ctx context.Context, arg ListRelationshipsBySubjectParams) ([]Relationship, error) {
	rows, err := q.db.Query(ctx, listRelationshipsBySubject, arg.SubjectType, arg.SubjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Relationship{}
	for rows.Next() {
		var i Relationship
		if err := rows.Scan(
			&i.ID,
			&i.SubjectType,
			&i.SubjectID,
			&i.Relation,
			&i.ObjectType,
			&i.ObjectID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const relationshipExists = `-- name: RelationshipExists :one
SELECT EXISTS(
    SELECT 1 FROM relationships
    WHERE subject_type = $1 AND subject_id = $2 AND relation = $3 AND object_type = $4 AND object_id = $5
)
`

type RelationshipExistsParams struct {
	SubjectType string    `json:"subject_type"`
	SubjectID   uuid.UUID `json:"subject_id"`
	Relation    string    `json:"relation"`
	ObjectType  string    `json:"object_type"`
	ObjectID    uuid.UUID `json:"object_id"`
}

func (q *Queries) RelationshipExists(ctx context.Context, arg RelationshipExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, relationshipExists,
		arg.SubjectType,
		arg.SubjectID,
		arg.Relation,
		arg.ObjectType,
		arg.ObjectID,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
