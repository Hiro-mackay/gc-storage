// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: upload_sessions.sql

package sqlcgen

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const abortUploadSession = `-- name: AbortUploadSession :exec
UPDATE upload_sessions SET status = 'aborted' WHERE id = $1
`

func (q *Queries) AbortUploadSession(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, abortUploadSession, id)
	return err
}

const completeUploadSession = `-- name: CompleteUploadSession :exec
UPDATE upload_sessions SET status = 'completed', completed_at = NOW() WHERE id = $1
`

func (q *Queries) CompleteUploadSession(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, completeUploadSession, id)
	return err
}

const createUploadSession = `-- name: CreateUploadSession :one
INSERT INTO upload_sessions (
    id, file_id, upload_id, status, total_parts, completed_parts, expires_at, created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, file_id, upload_id, status, total_parts, completed_parts, expires_at, created_at, completed_at
`

type CreateUploadSessionParams struct {
	ID             uuid.UUID `json:"id"`
	FileID         uuid.UUID `json:"file_id"`
	UploadID       *string   `json:"upload_id"`
	Status         string    `json:"status"`
	TotalParts     *int32    `json:"total_parts"`
	CompletedParts *int32    `json:"completed_parts"`
	ExpiresAt      time.Time `json:"expires_at"`
	CreatedAt      time.Time `json:"created_at"`
}

func (q *Queries) CreateUploadSession(ctx context.Context, arg CreateUploadSessionParams) (UploadSession, error) {
	row := q.db.QueryRow(ctx, createUploadSession,
		arg.ID,
		arg.FileID,
		arg.UploadID,
		arg.Status,
		arg.TotalParts,
		arg.CompletedParts,
		arg.ExpiresAt,
		arg.CreatedAt,
	)
	var i UploadSession
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.UploadID,
		&i.Status,
		&i.TotalParts,
		&i.CompletedParts,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const deleteExpiredUploadSessions = `-- name: DeleteExpiredUploadSessions :exec
DELETE FROM upload_sessions
WHERE status IN ('completed', 'failed', 'aborted') AND created_at < $1
`

func (q *Queries) DeleteExpiredUploadSessions(ctx context.Context, createdAt time.Time) error {
	_, err := q.db.Exec(ctx, deleteExpiredUploadSessions, createdAt)
	return err
}

const failUploadSession = `-- name: FailUploadSession :exec
UPDATE upload_sessions SET status = 'failed' WHERE id = $1
`

func (q *Queries) FailUploadSession(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, failUploadSession, id)
	return err
}

const getActiveUploadSessionByFileID = `-- name: GetActiveUploadSessionByFileID :one
SELECT id, file_id, upload_id, status, total_parts, completed_parts, expires_at, created_at, completed_at FROM upload_sessions
WHERE file_id = $1 AND status IN ('initiated', 'uploading', 'completing')
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetActiveUploadSessionByFileID(ctx context.Context, fileID uuid.UUID) (UploadSession, error) {
	row := q.db.QueryRow(ctx, getActiveUploadSessionByFileID, fileID)
	var i UploadSession
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.UploadID,
		&i.Status,
		&i.TotalParts,
		&i.CompletedParts,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getUploadSessionByID = `-- name: GetUploadSessionByID :one
SELECT id, file_id, upload_id, status, total_parts, completed_parts, expires_at, created_at, completed_at FROM upload_sessions WHERE id = $1
`

func (q *Queries) GetUploadSessionByID(ctx context.Context, id uuid.UUID) (UploadSession, error) {
	row := q.db.QueryRow(ctx, getUploadSessionByID, id)
	var i UploadSession
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.UploadID,
		&i.Status,
		&i.TotalParts,
		&i.CompletedParts,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const incrementCompletedParts = `-- name: IncrementCompletedParts :exec
UPDATE upload_sessions SET completed_parts = completed_parts + 1 WHERE id = $1
`

func (q *Queries) IncrementCompletedParts(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementCompletedParts, id)
	return err
}

const listExpiredUploadSessions = `-- name: ListExpiredUploadSessions :many
SELECT id, file_id, upload_id, status, total_parts, completed_parts, expires_at, created_at, completed_at FROM upload_sessions
WHERE status IN ('initiated', 'uploading') AND expires_at < NOW()
`

func (q *Queries) ListExpiredUploadSessions(ctx context.Context) ([]UploadSession, error) {
	rows, err := q.db.Query(ctx, listExpiredUploadSessions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UploadSession{}
	for rows.Next() {
		var i UploadSession
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.UploadID,
			&i.Status,
			&i.TotalParts,
			&i.CompletedParts,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUploadSession = `-- name: UpdateUploadSession :one
UPDATE upload_sessions SET
    upload_id = COALESCE($2, upload_id),
    status = COALESCE($3, status),
    total_parts = COALESCE($4, total_parts),
    completed_parts = COALESCE($5, completed_parts),
    completed_at = COALESCE($6, completed_at)
WHERE id = $1
RETURNING id, file_id, upload_id, status, total_parts, completed_parts, expires_at, created_at, completed_at
`

type UpdateUploadSessionParams struct {
	ID             uuid.UUID          `json:"id"`
	UploadID       *string            `json:"upload_id"`
	Status         *string            `json:"status"`
	TotalParts     *int32             `json:"total_parts"`
	CompletedParts *int32             `json:"completed_parts"`
	CompletedAt    pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) UpdateUploadSession(ctx context.Context, arg UpdateUploadSessionParams) (UploadSession, error) {
	row := q.db.QueryRow(ctx, updateUploadSession,
		arg.ID,
		arg.UploadID,
		arg.Status,
		arg.TotalParts,
		arg.CompletedParts,
		arg.CompletedAt,
	)
	var i UploadSession
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.UploadID,
		&i.Status,
		&i.TotalParts,
		&i.CompletedParts,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.CompletedAt,
	)
	return i, err
}
