// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: upload_sessions.sql

package sqlcgen

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createUploadSession = `-- name: CreateUploadSession :one
INSERT INTO upload_sessions (
    id, file_id, owner_id, owner_type, folder_id, file_name, mime_type, total_size,
    storage_key, minio_upload_id, is_multipart, total_parts, uploaded_parts, status,
    created_at, updated_at, expires_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
) RETURNING id, file_id, owner_id, owner_type, folder_id, file_name, mime_type, total_size, storage_key, minio_upload_id, is_multipart, total_parts, uploaded_parts, status, created_at, updated_at, expires_at
`

type CreateUploadSessionParams struct {
	ID            uuid.UUID           `json:"id"`
	FileID        uuid.UUID           `json:"file_id"`
	OwnerID       uuid.UUID           `json:"owner_id"`
	OwnerType     OwnerType           `json:"owner_type"`
	FolderID      pgtype.UUID         `json:"folder_id"`
	FileName      string              `json:"file_name"`
	MimeType      string              `json:"mime_type"`
	TotalSize     int64               `json:"total_size"`
	StorageKey    string              `json:"storage_key"`
	MinioUploadID *string             `json:"minio_upload_id"`
	IsMultipart   bool                `json:"is_multipart"`
	TotalParts    int32               `json:"total_parts"`
	UploadedParts int32               `json:"uploaded_parts"`
	Status        UploadSessionStatus `json:"status"`
	CreatedAt     time.Time           `json:"created_at"`
	UpdatedAt     time.Time           `json:"updated_at"`
	ExpiresAt     time.Time           `json:"expires_at"`
}

func (q *Queries) CreateUploadSession(ctx context.Context, arg CreateUploadSessionParams) (UploadSession, error) {
	row := q.db.QueryRow(ctx, createUploadSession,
		arg.ID,
		arg.FileID,
		arg.OwnerID,
		arg.OwnerType,
		arg.FolderID,
		arg.FileName,
		arg.MimeType,
		arg.TotalSize,
		arg.StorageKey,
		arg.MinioUploadID,
		arg.IsMultipart,
		arg.TotalParts,
		arg.UploadedParts,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ExpiresAt,
	)
	var i UploadSession
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.OwnerID,
		&i.OwnerType,
		&i.FolderID,
		&i.FileName,
		&i.MimeType,
		&i.TotalSize,
		&i.StorageKey,
		&i.MinioUploadID,
		&i.IsMultipart,
		&i.TotalParts,
		&i.UploadedParts,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const deleteUploadSession = `-- name: DeleteUploadSession :exec
DELETE FROM upload_sessions WHERE id = $1
`

func (q *Queries) DeleteUploadSession(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUploadSession, id)
	return err
}

const getUploadSessionByFileID = `-- name: GetUploadSessionByFileID :one
SELECT id, file_id, owner_id, owner_type, folder_id, file_name, mime_type, total_size, storage_key, minio_upload_id, is_multipart, total_parts, uploaded_parts, status, created_at, updated_at, expires_at FROM upload_sessions
WHERE file_id = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetUploadSessionByFileID(ctx context.Context, fileID uuid.UUID) (UploadSession, error) {
	row := q.db.QueryRow(ctx, getUploadSessionByFileID, fileID)
	var i UploadSession
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.OwnerID,
		&i.OwnerType,
		&i.FolderID,
		&i.FileName,
		&i.MimeType,
		&i.TotalSize,
		&i.StorageKey,
		&i.MinioUploadID,
		&i.IsMultipart,
		&i.TotalParts,
		&i.UploadedParts,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getUploadSessionByID = `-- name: GetUploadSessionByID :one
SELECT id, file_id, owner_id, owner_type, folder_id, file_name, mime_type, total_size, storage_key, minio_upload_id, is_multipart, total_parts, uploaded_parts, status, created_at, updated_at, expires_at FROM upload_sessions WHERE id = $1
`

func (q *Queries) GetUploadSessionByID(ctx context.Context, id uuid.UUID) (UploadSession, error) {
	row := q.db.QueryRow(ctx, getUploadSessionByID, id)
	var i UploadSession
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.OwnerID,
		&i.OwnerType,
		&i.FolderID,
		&i.FileName,
		&i.MimeType,
		&i.TotalSize,
		&i.StorageKey,
		&i.MinioUploadID,
		&i.IsMultipart,
		&i.TotalParts,
		&i.UploadedParts,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getUploadSessionByStorageKey = `-- name: GetUploadSessionByStorageKey :one
SELECT id, file_id, owner_id, owner_type, folder_id, file_name, mime_type, total_size, storage_key, minio_upload_id, is_multipart, total_parts, uploaded_parts, status, created_at, updated_at, expires_at FROM upload_sessions
WHERE storage_key = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetUploadSessionByStorageKey(ctx context.Context, storageKey string) (UploadSession, error) {
	row := q.db.QueryRow(ctx, getUploadSessionByStorageKey, storageKey)
	var i UploadSession
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.OwnerID,
		&i.OwnerType,
		&i.FolderID,
		&i.FileName,
		&i.MimeType,
		&i.TotalSize,
		&i.StorageKey,
		&i.MinioUploadID,
		&i.IsMultipart,
		&i.TotalParts,
		&i.UploadedParts,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const incrementUploadedParts = `-- name: IncrementUploadedParts :exec
UPDATE upload_sessions
SET uploaded_parts = uploaded_parts + 1, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) IncrementUploadedParts(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementUploadedParts, id)
	return err
}

const listExpiredUploadSessions = `-- name: ListExpiredUploadSessions :many
SELECT id, file_id, owner_id, owner_type, folder_id, file_name, mime_type, total_size, storage_key, minio_upload_id, is_multipart, total_parts, uploaded_parts, status, created_at, updated_at, expires_at FROM upload_sessions
WHERE status IN ('pending', 'in_progress') AND expires_at < NOW()
`

func (q *Queries) ListExpiredUploadSessions(ctx context.Context) ([]UploadSession, error) {
	rows, err := q.db.Query(ctx, listExpiredUploadSessions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UploadSession{}
	for rows.Next() {
		var i UploadSession
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.OwnerID,
			&i.OwnerType,
			&i.FolderID,
			&i.FileName,
			&i.MimeType,
			&i.TotalSize,
			&i.StorageKey,
			&i.MinioUploadID,
			&i.IsMultipart,
			&i.TotalParts,
			&i.UploadedParts,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUploadSession = `-- name: UpdateUploadSession :one
UPDATE upload_sessions SET
    minio_upload_id = COALESCE($2, minio_upload_id),
    uploaded_parts = COALESCE($3, uploaded_parts),
    status = COALESCE($4, status),
    updated_at = NOW()
WHERE id = $1
RETURNING id, file_id, owner_id, owner_type, folder_id, file_name, mime_type, total_size, storage_key, minio_upload_id, is_multipart, total_parts, uploaded_parts, status, created_at, updated_at, expires_at
`

type UpdateUploadSessionParams struct {
	ID            uuid.UUID               `json:"id"`
	MinioUploadID *string                 `json:"minio_upload_id"`
	UploadedParts *int32                  `json:"uploaded_parts"`
	Status        NullUploadSessionStatus `json:"status"`
}

func (q *Queries) UpdateUploadSession(ctx context.Context, arg UpdateUploadSessionParams) (UploadSession, error) {
	row := q.db.QueryRow(ctx, updateUploadSession,
		arg.ID,
		arg.MinioUploadID,
		arg.UploadedParts,
		arg.Status,
	)
	var i UploadSession
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.OwnerID,
		&i.OwnerType,
		&i.FolderID,
		&i.FileName,
		&i.MimeType,
		&i.TotalSize,
		&i.StorageKey,
		&i.MinioUploadID,
		&i.IsMultipart,
		&i.TotalParts,
		&i.UploadedParts,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const updateUploadSessionStatus = `-- name: UpdateUploadSessionStatus :exec
UPDATE upload_sessions SET status = $2, updated_at = NOW() WHERE id = $1
`

type UpdateUploadSessionStatusParams struct {
	ID     uuid.UUID           `json:"id"`
	Status UploadSessionStatus `json:"status"`
}

func (q *Queries) UpdateUploadSessionStatus(ctx context.Context, arg UpdateUploadSessionStatusParams) error {
	_, err := q.db.Exec(ctx, updateUploadSessionStatus, arg.ID, arg.Status)
	return err
}
