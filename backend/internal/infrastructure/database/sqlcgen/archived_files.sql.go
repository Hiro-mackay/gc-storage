// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: archived_files.sql

package sqlcgen

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createArchivedFile = `-- name: CreateArchivedFile :one
INSERT INTO archived_files (
    id, original_file_id, original_folder_id, original_path, name, mime_type, size,
    owner_id, created_by, storage_key, archived_at, archived_by, expires_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING id, original_file_id, original_folder_id, original_path, name, mime_type, size, owner_id, storage_key, archived_at, archived_by, expires_at, created_by
`

type CreateArchivedFileParams struct {
	ID               uuid.UUID `json:"id"`
	OriginalFileID   uuid.UUID `json:"original_file_id"`
	OriginalFolderID uuid.UUID `json:"original_folder_id"`
	OriginalPath     string    `json:"original_path"`
	Name             string    `json:"name"`
	MimeType         string    `json:"mime_type"`
	Size             int64     `json:"size"`
	OwnerID          uuid.UUID `json:"owner_id"`
	CreatedBy        uuid.UUID `json:"created_by"`
	StorageKey       string    `json:"storage_key"`
	ArchivedAt       time.Time `json:"archived_at"`
	ArchivedBy       uuid.UUID `json:"archived_by"`
	ExpiresAt        time.Time `json:"expires_at"`
}

func (q *Queries) CreateArchivedFile(ctx context.Context, arg CreateArchivedFileParams) (ArchivedFile, error) {
	row := q.db.QueryRow(ctx, createArchivedFile,
		arg.ID,
		arg.OriginalFileID,
		arg.OriginalFolderID,
		arg.OriginalPath,
		arg.Name,
		arg.MimeType,
		arg.Size,
		arg.OwnerID,
		arg.CreatedBy,
		arg.StorageKey,
		arg.ArchivedAt,
		arg.ArchivedBy,
		arg.ExpiresAt,
	)
	var i ArchivedFile
	err := row.Scan(
		&i.ID,
		&i.OriginalFileID,
		&i.OriginalFolderID,
		&i.OriginalPath,
		&i.Name,
		&i.MimeType,
		&i.Size,
		&i.OwnerID,
		&i.StorageKey,
		&i.ArchivedAt,
		&i.ArchivedBy,
		&i.ExpiresAt,
		&i.CreatedBy,
	)
	return i, err
}

const deleteArchivedFile = `-- name: DeleteArchivedFile :exec
DELETE FROM archived_files WHERE id = $1
`

func (q *Queries) DeleteArchivedFile(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteArchivedFile, id)
	return err
}

const getArchivedFileByID = `-- name: GetArchivedFileByID :one
SELECT id, original_file_id, original_folder_id, original_path, name, mime_type, size, owner_id, storage_key, archived_at, archived_by, expires_at, created_by FROM archived_files WHERE id = $1
`

func (q *Queries) GetArchivedFileByID(ctx context.Context, id uuid.UUID) (ArchivedFile, error) {
	row := q.db.QueryRow(ctx, getArchivedFileByID, id)
	var i ArchivedFile
	err := row.Scan(
		&i.ID,
		&i.OriginalFileID,
		&i.OriginalFolderID,
		&i.OriginalPath,
		&i.Name,
		&i.MimeType,
		&i.Size,
		&i.OwnerID,
		&i.StorageKey,
		&i.ArchivedAt,
		&i.ArchivedBy,
		&i.ExpiresAt,
		&i.CreatedBy,
	)
	return i, err
}

const getArchivedFileByOriginalFileID = `-- name: GetArchivedFileByOriginalFileID :one
SELECT id, original_file_id, original_folder_id, original_path, name, mime_type, size, owner_id, storage_key, archived_at, archived_by, expires_at, created_by FROM archived_files WHERE original_file_id = $1
`

func (q *Queries) GetArchivedFileByOriginalFileID(ctx context.Context, originalFileID uuid.UUID) (ArchivedFile, error) {
	row := q.db.QueryRow(ctx, getArchivedFileByOriginalFileID, originalFileID)
	var i ArchivedFile
	err := row.Scan(
		&i.ID,
		&i.OriginalFileID,
		&i.OriginalFolderID,
		&i.OriginalPath,
		&i.Name,
		&i.MimeType,
		&i.Size,
		&i.OwnerID,
		&i.StorageKey,
		&i.ArchivedAt,
		&i.ArchivedBy,
		&i.ExpiresAt,
		&i.CreatedBy,
	)
	return i, err
}

const listArchivedFilesByOwner = `-- name: ListArchivedFilesByOwner :many
SELECT id, original_file_id, original_folder_id, original_path, name, mime_type, size, owner_id, storage_key, archived_at, archived_by, expires_at, created_by FROM archived_files
WHERE owner_id = $1
ORDER BY archived_at DESC
`

func (q *Queries) ListArchivedFilesByOwner(ctx context.Context, ownerID uuid.UUID) ([]ArchivedFile, error) {
	rows, err := q.db.Query(ctx, listArchivedFilesByOwner, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ArchivedFile{}
	for rows.Next() {
		var i ArchivedFile
		if err := rows.Scan(
			&i.ID,
			&i.OriginalFileID,
			&i.OriginalFolderID,
			&i.OriginalPath,
			&i.Name,
			&i.MimeType,
			&i.Size,
			&i.OwnerID,
			&i.StorageKey,
			&i.ArchivedAt,
			&i.ArchivedBy,
			&i.ExpiresAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listArchivedFilesByOwnerWithPagination = `-- name: ListArchivedFilesByOwnerWithPagination :many
SELECT id, original_file_id, original_folder_id, original_path, name, mime_type, size, owner_id, storage_key, archived_at, archived_by, expires_at, created_by FROM archived_files
WHERE owner_id = $1
  AND (
    $3::uuid IS NULL
    OR id < $3::uuid
  )
ORDER BY archived_at DESC, id DESC
LIMIT $2
`

type ListArchivedFilesByOwnerWithPaginationParams struct {
	OwnerID  uuid.UUID   `json:"owner_id"`
	Limit    int32       `json:"limit"`
	CursorID pgtype.UUID `json:"cursor_id"`
}

func (q *Queries) ListArchivedFilesByOwnerWithPagination(ctx context.Context, arg ListArchivedFilesByOwnerWithPaginationParams) ([]ArchivedFile, error) {
	rows, err := q.db.Query(ctx, listArchivedFilesByOwnerWithPagination, arg.OwnerID, arg.Limit, arg.CursorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ArchivedFile{}
	for rows.Next() {
		var i ArchivedFile
		if err := rows.Scan(
			&i.ID,
			&i.OriginalFileID,
			&i.OriginalFolderID,
			&i.OriginalPath,
			&i.Name,
			&i.MimeType,
			&i.Size,
			&i.OwnerID,
			&i.StorageKey,
			&i.ArchivedAt,
			&i.ArchivedBy,
			&i.ExpiresAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExpiredArchivedFiles = `-- name: ListExpiredArchivedFiles :many
SELECT id, original_file_id, original_folder_id, original_path, name, mime_type, size, owner_id, storage_key, archived_at, archived_by, expires_at, created_by FROM archived_files
WHERE expires_at < NOW()
`

func (q *Queries) ListExpiredArchivedFiles(ctx context.Context) ([]ArchivedFile, error) {
	rows, err := q.db.Query(ctx, listExpiredArchivedFiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ArchivedFile{}
	for rows.Next() {
		var i ArchivedFile
		if err := rows.Scan(
			&i.ID,
			&i.OriginalFileID,
			&i.OriginalFolderID,
			&i.OriginalPath,
			&i.Name,
			&i.MimeType,
			&i.Size,
			&i.OwnerID,
			&i.StorageKey,
			&i.ArchivedAt,
			&i.ArchivedBy,
			&i.ExpiresAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
