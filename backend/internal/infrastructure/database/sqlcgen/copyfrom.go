// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: copyfrom.go

package sqlcgen

import (
	"context"
)

// iteratorForCreateArchivedFileVersionsBulk implements pgx.CopyFromSource.
type iteratorForCreateArchivedFileVersionsBulk struct {
	rows                 []CreateArchivedFileVersionsBulkParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateArchivedFileVersionsBulk) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateArchivedFileVersionsBulk) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].ArchivedFileID,
		r.rows[0].OriginalVersionID,
		r.rows[0].VersionNumber,
		r.rows[0].MinioVersionID,
		r.rows[0].Size,
		r.rows[0].Checksum,
		r.rows[0].UploadedBy,
		r.rows[0].CreatedAt,
	}, nil
}

func (r iteratorForCreateArchivedFileVersionsBulk) Err() error {
	return nil
}

func (q *Queries) CreateArchivedFileVersionsBulk(ctx context.Context, arg []CreateArchivedFileVersionsBulkParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"archived_file_versions"}, []string{"id", "archived_file_id", "original_version_id", "version_number", "minio_version_id", "size", "checksum", "uploaded_by", "created_at"}, &iteratorForCreateArchivedFileVersionsBulk{rows: arg})
}

// iteratorForCreateFileVersionsBulk implements pgx.CopyFromSource.
type iteratorForCreateFileVersionsBulk struct {
	rows                 []CreateFileVersionsBulkParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateFileVersionsBulk) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateFileVersionsBulk) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].FileID,
		r.rows[0].VersionNumber,
		r.rows[0].MinioVersionID,
		r.rows[0].Size,
		r.rows[0].Checksum,
		r.rows[0].UploadedBy,
		r.rows[0].CreatedAt,
	}, nil
}

func (r iteratorForCreateFileVersionsBulk) Err() error {
	return nil
}

func (q *Queries) CreateFileVersionsBulk(ctx context.Context, arg []CreateFileVersionsBulkParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"file_versions"}, []string{"id", "file_id", "version_number", "minio_version_id", "size", "checksum", "uploaded_by", "created_at"}, &iteratorForCreateFileVersionsBulk{rows: arg})
}

// iteratorForInsertFolderPathsBulk implements pgx.CopyFromSource.
type iteratorForInsertFolderPathsBulk struct {
	rows                 []InsertFolderPathsBulkParams
	skippedFirstNextCall bool
}

func (r *iteratorForInsertFolderPathsBulk) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForInsertFolderPathsBulk) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].AncestorID,
		r.rows[0].DescendantID,
		r.rows[0].PathLength,
		r.rows[0].CreatedAt,
	}, nil
}

func (r iteratorForInsertFolderPathsBulk) Err() error {
	return nil
}

func (q *Queries) InsertFolderPathsBulk(ctx context.Context, arg []InsertFolderPathsBulkParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"folder_paths"}, []string{"ancestor_id", "descendant_id", "path_length", "created_at"}, &iteratorForInsertFolderPathsBulk{rows: arg})
}
